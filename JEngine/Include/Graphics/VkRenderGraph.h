#pragma once
#include "JEngine/Graphics/VkImage.h"
#include "JEngine/Graphics/VkPipeline.h"
#include "Jlb/Array.h"
#include "Jlb/LinkedList.h"
#include "Jlb/Queue.h"

namespace je::vk
{
	class Allocator;
	class SwapChain;
	struct App;

	// Render function used by the render graph.
	typedef void(*RenderFunc)(VkCommandBuffer cmdBuffer, VkPipelineLayout layout, void* userPtr, size_t frameIndex);

	// Defines the behaviour of a node in a render graph.
	struct RenderNode final
	{
		// Input/Output generated by the render graph.
		struct Resource final
		{
			glm::ivec2 resolution;
			[[nodiscard]] bool operator==(const Resource& other) const;
		};

		// Can be linked to the input of other nodes with the name.
		struct Output final
		{
			const char* name;
			Resource resource;
		};

		// The names of all the render graph resources that will be used as inputs.
		Array<const char*> inputs{};
		// The names of all the render graph resources that will be used as outputs.
		Array<Output> outputs{};
		// The descriptor set layouts used for rendering.
		Array<VkDescriptorSetLayout> layouts{};
		// Shader modules used for rendering.
		Array<PipelineCreateInfo::Module> modules{};

		// Function called during rendering.
		RenderFunc renderFunc = nullptr;
		// Pointer that will be forwarded to the render function.
		void* userPtr = nullptr;

		// This will be filled with the image views for the inputs. View will have to be defined by the end user.
		Array<VkImageView> outImageViews{};
	};

	// Tool to simplify and abstract render steps like post effects, deferred lighting and more.
	class RenderGraph final
	{
	public:
		RenderGraph(Arena& arena, Arena& tempArena, App& app, Allocator& allocator, SwapChain& swapChain, const Array<RenderNode>& nodes);
		~RenderGraph();

		// Goes through the render graph nodes and renders them.
		[[nodiscard]] VkSemaphore Update() const;
		// Returns the image view for the final image of the render graph.
		[[nodiscard]] VkImageView GetResult(size_t frameIndex) const;

	private:
		struct TempResource final
		{
			struct Variation final
			{
				const char* name;
				size_t lifeTimeStart = 0;
				size_t lifeTimeEnd = 0;
				size_t imageIndex = SIZE_MAX;
			};

			RenderNode::Resource resource{};
			LinkedList<Variation> variations{};
			Queue<size_t> imageQueue{};
			size_t count = 0;
			size_t lifeTimeEnd = 0;
		};

		struct TempNode final
		{
			const RenderNode* renderNode = nullptr;

			size_t index = SIZE_MAX;
			size_t depth = 0;
			bool isRoot = true;

			LinkedList<TempNode*> children{};
			LinkedList<TempResource*> inputResources{};
			LinkedList<TempResource*> outputResources{};
			LinkedList<TempResource::Variation*> inputResourceVariations{};
			LinkedList<TempResource::Variation*> outputResourceVariations{};
		};

		struct Node final
		{
			RenderFunc renderFunc = nullptr;
			void* userPtr = nullptr;
			VkRenderPass renderPass;
			Array<VkFramebuffer> frameBuffers{};
			Pipeline pipeline{};
			glm::ivec2 resolution;
			size_t inputCount = 0;
			size_t outputCount = 0;
		};

		struct Layer final
		{
			struct Frame final
			{
				VkCommandBuffer cmdBuffer = VK_NULL_HANDLE;
				VkSemaphore semaphore = VK_NULL_HANDLE;
			};

			size_t index;
			Array<Frame> frames{};
		};

		struct Attachment final
		{
			Image image{};
			VkImageView view = VK_NULL_HANDLE;
		};

		Arena& _arena;
		App& _app;
		Allocator& _allocator;
		SwapChain& _swapChain;

		Array<size_t> _attachmentIndexes{};
		Array<Attachment> _attachments{};
		Array<Node> _nodes{};
		Array<Layer> _layers{};

		static void DefineDepth(TempNode& node, size_t depth);
		static bool SortDepthNodes(TempNode*& a, TempNode*& b);
	};
}
